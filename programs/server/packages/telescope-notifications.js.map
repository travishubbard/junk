{"version":3,"file":"/packages/telescope-notifications.js","sources":["telescope-notifications/lib/notifications.js","telescope-notifications/lib/server/notifications-server.js","telescope-notifications/lib/server/publication.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,uD;;AAEA,2D;AACA,+B;AACA,oB;AACA,qB;AACA,S;AACA,e;AACA,qB;AACA,S;AACA,c;AACA,sB;AACA,S;AACA,mB;AACA,mB;AACA,S;AACA,gB;AACA,oB;AACA,Q;AACA,O;AACA,M;;AAEA,qB;AACA,gC;AACA,gE;AACA,iB;AACA,I;AACA,uB;AACA,sB;AACA,G;;AAEA,gE;AACA,sC;AACA,sB;AACA,oC;AACA,6B;AACA,iB;AACA,2B;AACA,e;AACA,I;AACA,6D;;AAEA,iD;AACA,sF;AACA,qE;AACA,mC;AACA,+D;AACA,2F;AACA,U;AACA,G;AACA,E;;AAEA,iD;AACA,iC;AACA,gD;AACA,0C;AACA,+D;AACA,e;AACA,W;;AAEA,oB;AACA,kD;AACA,2B;AACA,6D;AACA,yB;AACA,I;;AAEA,gB;AACA,oB;AACA,wC;AACA,Y;;AAEA,sB;AACA,0C;AACA,a;;AAEA,Y;AACA,Y;AACA,G;;AAEA,wD;AACA,0C;AACA,M;;AAEA,c;AACA,E;;AAEA,gB;AACA,0C;AACA,yB;AACA,gC;AACA,O;AACA,c;AACA,oB;AACA,S;AACA,Q;AACA,mB;AACA,M;AACA,G;AACA,G;;AAEA,oD;AACA,qD;AACA,mE;AACA,4G;AACA,mC;AACA,8C;AACA,U;AACA,G;AACA,c;AACA,G;;AAEA,0D;AACA,2D;AACA,sB;;AAEA,kD;AACA,6B;AACA,6C;AACA,qD;;AAEA,kC;AACA,kE;AACA,+C;AACA,M;;AAEA,wB;AACA,sB;AACA,4D;AACA,kE;;AAEA,8F;;AAEA,2B;AACA,uF;AACA,oC;AACA,2E;;AAEA,6B;AACA,mG;AACA,yE;AACA,2E;;AAEA,U;AACA,qB;AACA,iD;AACA,kC;AACA,2E;AACA,K;AACA,G;;AAEA,iB;AACA,G;;;;;;;;;;;;;;;;;;ACxJA,oC;AACA,6D;AACA,E;;AAEA,6E;AACA,kD;AACA,E;AACA,wB;AACA,0C;AACA,gD;AACA,E;AACA,6B;AACA,oB;AACA,sE;AACA,iC;AACA,Y;;AAEA,sB;AACA,8D;AACA,mC;AACA,a;;AAEA,Y;AACA,Y;AACA,G;;AAEA,2D;AACA,+B;AACA,kD;AACA,6D;AACA,+B;AACA,K;;AAEA,iC;;AAEA,qE;AACA,kD;;AAEA,U;AACA,qB;AACA,c;AACA,G;AACA,E;;AAEA,kD;AACA,yE;AACA,kC;AACA,yE;AACA,qE;;AAEA,gF;AACA,gF;AACA,mE;AACA,2C;AACA,+C;AACA,K;AACA,E;;AAEA,gB;AACA,mC;AACA,8E;AACA,iF;AACA,wD;AACA,a;AACA,kD;AACA,e;AACA,4C;AACA,4C;AACA,+C;AACA,6C;AACA,S;AACA,S;AACA,kB;AACA,K;AACA,iB;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;;AC5EA,4C;AACA,6D;AACA,+B;AACA,oD;AACA,G;AACA,Y;AACA,G","sourcesContent":["Notifications = new Meteor.Collection('notifications');\n\n// Notifications = new Meteor.Collection(\"notifications\", {\n//   schema: new SimpleSchema({\n//     properties: {\n//       type: Object\n//     },\n//     event: {\n//       type: String\n//     },\n//     read: {\n//       type: Boolean\n//     },\n//     createdAt: {\n//       type: Date\n//     },\n//     userId: {\n//       type: \"???\"\n//     }\n//   })\n// });\n\nNotifications.allow({\n  insert: function(userId, doc){\n    // new notifications can only be created via a Meteor method\n    return false;\n  },\n  update: can.editById,\n  remove: can.editById\n});\n\ncreateNotification = function(event, properties, userToNotify) {\n  // 1. Store notification in database\n  var notification = {\n    timestamp: new Date().getTime(),\n    userId: userToNotify._id,\n    event: event,\n    properties: properties,\n    read: false\n  };\n  var newNotificationId = Notifications.insert(notification);\n\n  // 2. Send notification by email (if on server)\n  if(Meteor.isServer && getUserSetting('notifications.replies', false, userToNotify)){\n    // put in setTimeout so it doesn't hold up the rest of the method\n    Meteor.setTimeout(function () {\n      notificationEmail = buildEmailNotification(notification);\n      sendEmail(getEmail(userToNotify), notificationEmail.subject, notificationEmail.html);\n    }, 1);\n  }\n};\n\nbuildSiteNotification = function (notification) {\n  var event = notification.event,\n      comment = notification.properties.comment,\n      post = notification.properties.post,\n      userToNotify = Meteor.users.findOne(notification.userId),\n      template,\n      html;\n\n  var properties = {\n    profileUrl: getProfileUrlById(comment.userId),\n    author: comment.author,\n    postCommentUrl: getPostCommentUrl(post._id, comment._id),\n    postTitle: post.title\n  };\n\n  switch(event){\n    case 'newReply':\n      template = 'notificationNewReply';\n      break;\n\n    case 'newComment':\n      template = 'notificationNewComment';\n      break; \n\n    default:\n      break;\n  }\n\n  html = Blaze.toHTML(Blaze.With(properties, function(){\n    return Template[getTemplate(template)]\n  }));\n\n  return html;\n};\n\nMeteor.methods({\n  markAllNotificationsAsRead: function() {\n    Notifications.update(\n      {userId: Meteor.userId()},\n      {\n        $set:{\n          read: true\n        }\n      },\n      {multi: true}\n    );\n  }\n});\n\n// add new post notification callback on post submit\npostAfterSubmitMethodCallbacks.push(function (post) {\n  if(Meteor.isServer && !!getSetting('emailNotifications', false)){\n    // we don't want emails to hold up the post submission, so we make the whole thing async with setTimeout\n    Meteor.setTimeout(function () {\n      newPostNotification(post, [post.userId])\n    }, 1);\n  }\n  return post;\n});\n\n// add new comment notification callback on comment submit\ncommentAfterSubmitMethodCallbacks.push(function (comment) {\n  if(Meteor.isServer){\n\n    var parentCommentId = comment.parentCommentId;\n    var user = Meteor.user();\n    var post = Posts.findOne(comment.postId);\n    var postUser = Meteor.users.findOne(post.userId);\n\n    var notificationProperties = {\n      comment: _.pick(comment, '_id', 'userId', 'author', 'body'),\n      post: _.pick(post, '_id', 'title', 'url')\n    };\n\n    if(parentCommentId){\n      // child comment\n      var parentComment = Comments.findOne(parentCommentId);\n      var parentUser = Meteor.users.findOne(parentComment.userId);\n\n      notificationProperties.parentComment = _.pick(parentComment, '_id', 'userId', 'author');\n\n      // reply notification\n      // do not notify users of their own actions (i.e. they're replying to themselves)\n      if(parentUser._id != user._id)\n        createNotification('newReply', notificationProperties, parentUser);\n\n      // comment notification\n      // if the original poster is different from the author of the parent comment, notify them too\n      if(postUser._id != user._id && parentComment.userId != post.userId)\n        createNotification('newComment', notificationProperties, postUser);\n\n    }else{\n      // root comment\n      // don't notify users of their own comments\n      if(postUser._id != user._id)\n        createNotification('newComment', notificationProperties, postUser);\n    }\n  }\n\n  return comment;\n});","getUnsubscribeLink = function(user){\n  return Meteor.absoluteUrl()+'unsubscribe/'+user.email_hash;\n};\n\n// given a notification, return the correct subject and html to send an email\nbuildEmailNotification = function (notification) {\n  \n  var subject, template;\n  var post = notification.properties.post;\n  var comment = notification.properties.comment;\n  \n  switch(notification.event){\n    case 'newReply':\n      subject = 'Someone replied to your comment on \"'+post.title+'\"';\n      template = 'emailNewReply';\n      break;\n\n    case 'newComment':\n      subject = 'A new comment on your post \"'+post.title+'\"';\n      template = 'emailNewComment';\n      break; \n\n    default:\n      break;\n  }\n\n  var emailProperties = _.extend(notification.properties, {\n    body: marked(comment.body),\n    profileUrl: getProfileUrlById(comment.userId),\n    postCommentUrl: getPostCommentUrl(post._id, comment._id),\n    postLink: getPostLink(post)\n  });\n\n  // console.log(emailProperties)\n\n  var notificationHtml = getEmailTemplate(template)(emailProperties);\n  var html = buildEmailTemplate(notificationHtml);\n\n  return {\n    subject: subject,\n    html: html\n  }\n};\n\nnewPostNotification = function(post, excludedIDs){\n  var excludedIDs = typeof excludedIDs == 'undefined' ? [] : excludedIDs;\n  var p = getPostProperties(post);\n  var subject = p.postAuthorName+' has created a new post: '+p.postTitle;\n  var html = buildEmailTemplate(getEmailTemplate('emailNewPost')(p));\n\n  // send a notification to every user according to their notifications settings\n  Meteor.users.find({'profile.notifications.posts': 1}).forEach(function(user) {\n    // don't send user a notification if their ID is in excludedIDs\n    if(excludedIDs.indexOf(user._id) == -1)\n      sendEmail(getEmail(user), subject, html);\n  });\n};\n\nMeteor.methods({\n  unsubscribeUser : function(hash){\n    // TO-DO: currently, if you have somebody's email you can unsubscribe them\n    // A user-specific salt should be added to the hashing method to prevent this\n    var user = Meteor.users.findOne({email_hash: hash});\n    if(user){\n      var update = Meteor.users.update(user._id, {\n        $set: {\n          'profile.notifications.users' : 0,\n          'profile.notifications.posts' : 0,\n          'profile.notifications.comments' : 0,\n          'profile.notifications.replies' : 0\n        }\n      });\n      return true;\n    }\n    return false;\n  }\n});\n\n","Meteor.publish('notifications', function() {\n  // only publish notifications belonging to the current user\n  if(canViewById(this.userId)){\n    return Notifications.find({userId:this.userId});\n  }\n  return [];\n});"]}