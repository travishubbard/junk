{"version":3,"file":"/packages/percolatestudio:synced-cron.js","sources":["percolatestudio:synced-cron/synced-cron-server.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;AAAA,oE;AACA,c;AACA,e;AACA,Y;AACA,c;AACA,kC;AACA,2C;AACA,G;AACA,C;;AAEA,6B;;AAEA,gD;AACA,2B;AACA,mB;AACA,I;AACA,yB;;AAEA,6C;AACA,yB;AACA,0D;AACA,8E;;AAEA,W;AACA,2B;AACA,+B;AACA,2B;AACA,G;AACA,C;;AAEA,sB;AACA,mB;AACA,sD;AACA,wE;AACA,qD;AACA,M;AACA,kC;AACA,4B;AACA,kC;AACA,6B;;AAEA,U;AACA,4B;AACA,C;;AAEA,8B;AACA,+B;AACA,kB;;AAEA,oC;AACA,yC;AACA,+C;AACA,+E;;AAEA,qE;AACA,0C;AACA,K;AACA,C;;AAEA,0E;AACA,qD;AACA,qD;AACA,kC;AACA,K;AACA,E;AACA,Y;AACA,+D;AACA,C;;AAEA,uB;AACA,8B;AACA,oB;AACA,wB;AACA,uB;AACA,G;AACA,C;;AAEA,0E;AACA,qE;AACA,4C;AACA,kB;;AAEA,+B;AACA,sB;AACA,6B;AACA,uB;AACA,2B;AACA,M;;AAEA,4E;AACA,gB;AACA,S;AACA,2D;AACA,gB;AACA,+D;AACA,qC;AACA,wD;AACA,wE;AACA,e;AACA,O;;AAEA,e;AACA,M;;AAEA,6B;AACA,S;AACA,6D;AACA,kE;AACA,E;AACA,6D;AACA,sD;AACA,e;AACA,iC;AACA,wB;AACA,S;AACA,S;;AAEA,mC;AACA,uE;AACA,gB;AACA,uE;AACA,sD;AACA,e;AACA,iC;AACA,wB;AACA,S;AACA,S;AACA,K;AACA,I;AACA,C;;AAEA,gD;AACA,uD;AACA,4B;AACA,wD;AACA,E;AACA,uE;AACA,C;;AAEA,Y;AACA,gC;AACA,qB;AACA,8B;AACA,C;;AAEA,8E;AACA,4E;AACA,mC;AACA,kD;AACA,kF;AACA,4E;AACA,8D;;AAEA,4E;AACA,oD;;AAEA,8D;AACA,mB;;AAEA,K;AACA,0E;AACA,a;AACA,I;AACA,wC;AACA,e;AACA,qB;AACA,8D;AACA,K;AACA,G;;AAEA,U;;AAEA,O;AACA,yB;AACA,M;AACA,uB;AACA,kB;AACA,gB;AACA,K;;AAEA,I;;AAEA,E;;AAEA,2E;AACA,mD;;AAEA,mC;AACA,oB;;AAEA,K;AACA,8E;AACA,4E;AACA,6C;AACA,I;AACA,8B;AACA,yB;AACA,8B;AACA,uC;AACA,6B;;AAEA,sE;AACA,qB;AACA,qC;AACA,2B;AACA,K;;AAEA,2B;AACA,kE;AACA,K;AACA,U;AACA,yD;AACA,K;AACA,G;;AAEA,U;;AAEA,O;AACA,yB;AACA,M;AACA,uB;AACA,6B;AACA,K;;AAEA,I;;AAEA,E;AACA,8E","sourcesContent":["// A package for running jobs synchronized across multiple processes\nSyncedCron = {\n  _entries: [],\n  options: {\n    log: true,\n    collectionName: 'cronHistory',\n    utc: false //default to using localTime\n  }\n}\n\nLater = Npm.require('later');\n\n// Use UTC or localtime for evaluating schedules\nif (SyncedCron.options.utc)\n  Later.date.UTC();\nelse\n  Later.date.localTime();\n\n// collection holding the job history records\nSyncedCron._collection = \n  new Mongo.Collection(SyncedCron.options.collectionName);\nSyncedCron._collection._ensureIndex({intendedAt: 1, name: 1}, {unique: true});\n\nvar log = {\n  info: function(message) {\n    if (SyncedCron.options.log)\n      console.log(message);\n  }\n}\n\n// add a scheduled job\n// SyncedCron.add({\n//   name: String, //*required* unique name of the job\n//   schedule: function(laterParser) {},//*required* when to run the job\n//   job: function() {}, //*required* the code to run\n// });\nSyncedCron.add = function(entry) {\n  check(entry.name, String);\n  check(entry.schedule, Function);\n  check(entry.job, Function);\n\n  // check\n  this._entries.push(entry);\n}\n\n// Start processing added jobs\nSyncedCron.start = function() {\n  var self = this;\n\n  // Schedule each job with later.js\n  this._entries.forEach(function(entry) {\n    var schedule = entry.schedule(Later.parse);\n    entry._timer = self._laterSetInterval(self._entryWrapper(entry), schedule);\n\n    log.info('SyncedCron: scheduled \"' + entry.name + '\" next run @' \n      + Later.schedule(schedule).next(1));\n  });\n}\n\n// Return the next scheduled date of the first matching entry or undefined\nSyncedCron.nextScheduledAtDate = function (jobName) {\n  var entry = _.find(this._entries, function(entry) {\n    return entry.name === jobName;\n  });\n  \n  if (entry)\n    return Later.schedule(entry.schedule(Later.parse)).next(1);\n}\n\n// Stop processing jobs\nSyncedCron.stop = function() {\n  if (this._timer) {\n    this._timer.clear();\n    this._timer = null;\n  }\n}\n\n// The meat of our logic. Checks if the specified has already run. If not,\n// records that it's running the job, runs it, and records the output\nSyncedCron._entryWrapper = function(entry) {\n  var self = this;\n\n  return function(intendedAt) {\n    var jobHistory = {\n      intendedAt: intendedAt,\n      name: entry.name,\n      startedAt: new Date()\n    };\n\n    // If we have a dup key error, another instance has already tried to run\n    // this job.\n    try {\n      jobHistory._id = self._collection.insert(jobHistory);\n    } catch(e) {\n      // http://www.mongodb.org/about/contributors/error-codes/\n      // 11000 == duplicate key error\n      if (e.name === 'MongoError' && e.code === 11000) {\n        log.info('SyncedCron: Not running \"' + entry.name + '\" again.');\n        return;\n      }\n\n      throw e; \n    };\n\n    // run and record the job\n    try {\n      log.info('SyncedCron: Starting \"' + entry.name + '\".');\n      var output = entry.job(intendedAt); // <- Run the actual job\n  \n      log.info('SyncedCron: Finished \"' + entry.name + '\".');\n      self._collection.update({_id: jobHistory._id}, {\n        $set: {\n          finishedAt: new Date(),\n          result: output\n        }\n      });\n\n      if (entry.purgeLogsAfterDays)\n        SyncedCron._purgeEntries(entry.name, entry.purgeLogsAfterDays);\n    } catch(e) {\n      log.info('SyncedCron: Exception \"' + entry.name +'\" ' + e.stack);\n      self._collection.update({_id: jobHistory._id}, {\n        $set: {\n          finishedAt: new Date(),\n          error: e.stack\n        }\n      });\n    }\n  };\n}\n\n// remove entries that are older than daysBefore\nSyncedCron._purgeEntries = function(name, daysBefore) {\n  var beforeDate = new Date;\n  beforeDate.setDate(beforeDate.getDate() - daysBefore);\n  \n  this._collection.remove({name: name, startedAt: {$lte: beforeDate}});\n}\n\n// for tests\nSyncedCron._reset = function() {\n  this._entries = [];\n  this._collection.remove({});\n}\n\n// ---------------------------------------------------------------------------\n// The following two functions are lifted from the later.js package, however\n// I've made the following changes:\n// - Use Meteor.setTimeout and Meteor.clearTimeout\n// - Added an 'intendedAt' parameter to the callback fn that specifies the precise\n//   time the callback function *should* be run (so we can co-ordinate jobs)\n//   between multiple, potentially laggy and unsynced machines\n\n// From: https://github.com/bunkat/later/blob/master/src/core/setinterval.js\nSyncedCron._laterSetInterval = function(fn, sched) {\n\n  var t = SyncedCron._laterSetTimeout(scheduleTimeout, sched),\n      done = false;\n\n  /**\n  * Executes the specified function and then sets the timeout for the next\n  * interval.\n  */\n  function scheduleTimeout(intendedAt) {\n    if(!done) {\n      fn(intendedAt);\n      t = SyncedCron._laterSetTimeout(scheduleTimeout, sched);\n    }\n  }\n\n  return {\n\n    /**\n    * Clears the timeout.\n    */\n    clear: function() {\n      done = true;\n      t.clear();\n    }\n\n  };\n\n};\n\n// From: https://github.com/bunkat/later/blob/master/src/core/settimeout.js\nSyncedCron._laterSetTimeout = function(fn, sched) {\n\n  var s = Later.schedule(sched), t;\n  scheduleTimeout();\n\n  /**\n  * Schedules the timeout to occur. If the next occurrence is greater than the\n  * max supported delay (2147483647 ms) than we delay for that amount before\n  * attempting to schedule the timeout again.\n  */\n  function scheduleTimeout() {\n    var now = Date.now(),\n        next = s.next(2, now),\n        diff = next[0].getTime() - now,\n        intendedAt = next[0];\n\n    // minimum time to fire is one second, use next occurrence instead\n    if(diff < 1000) {\n      diff = next[1].getTime() - now;\n      intendedAt = next[1];\n    }\n\n    if(diff < 2147483647) {\n      t = Meteor.setTimeout(function() { fn(intendedAt); }, diff);\n    }\n    else {\n      t = Meteor.setTimeout(scheduleTimeout, 2147483647);\n    }\n  }\n\n  return {\n\n    /**\n    * Clears the timeout.\n    */\n    clear: function() {\n      Meteor.clearTimeout(t);\n    }\n\n  };\n\n};\n// ---------------------------------------------------------------------------"]}